#include <Arduino.h>
#include <WiFi.h>
#include <Keypad.h>
#include <HTTPClient.h>
#include "esp_mac.h" // Para obtener la MAC address
#include "esp_timer.h"
#include <TFT_eSPI.h>
#include <ArduinoJson.h> // Para parsear JSON

// ===============================================
// CONFIGURACIÓN DE DEBUG
// ===============================================
// Descomenta la siguiente línea para habilitar logs de debug del teclado
//#define DEBUG_KEYPAD

// Descomenta esta línea para que el request se haga cada 20 segundos para debug
#define DEBUG_20_SEC_REQUEST

const byte ROWS = 4; // Cuatro filas
const byte COLS = 4; // Cuatro columnas

char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

// Pines para las filas (INPUT_PULLUP) - Mejorados para mayor confiabilidad
byte rowPins[ROWS] = {34, 35, 32, 33}; // 32 y 33 son más confiables que 39 y 36

// Pines para las columnas (OUTPUT) - Tu selección está bien
byte colPins[COLS] = {25, 26, 27, 14}; 

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
char KEY = 'x';

// ===============================================
// VARIABLES PARA SISTEMA DE PIN
// ===============================================
String inputDigits = "";                           // Almacena los dígitos ingresados (máximo 4)
bool pinReadyForValidation = false;                // Flag para indicar que hay 4 dígitos listos
bool pinValidationInProgress = false;              // Flag para indicar validación en progreso
enum PinValidationResult { PENDING, SUCCESS, FAILED };
volatile PinValidationResult pinResult = PENDING;
unsigned long pinResultDisplayTime = 0;           // Tiempo para mostrar resultado
const unsigned long PIN_RESULT_SHOW_DURATION = 3000; // 3 segundos mostrando resultado

// ===============================================
// VARIABLES PARA TECLADO OPTIMIZADO
// ===============================================
volatile bool keypadReadFlag = false;           // Flag para indicar cuándo leer el teclado
char lastValidKey = 0;                          // Última tecla válida presionada
unsigned long lastKeyTime = 0;                  // Tiempo de la última tecla para debounce
const unsigned long KEY_DEBOUNCE_TIME = 100;    // Tiempo de debounce en miliseconds (aumentado)
volatile bool httpRequestInProgress = false;    // Flag para debug - indica si HTTP está en progreso
SemaphoreHandle_t keypadSemaphore;              // Semáforo para proteger variables del teclado
SemaphoreHandle_t pinSemaphore;                 // Semáforo para proteger variables del PIN

TFT_eSPI tft = TFT_eSPI();

//https://rgbcolorpicker.com/565
#define WHITE 0xFFFF
#define BLACK 0x0000
#define TEXT_COLOR 0xFFFF
#define GREY_DOTS 0x2108 // Color para las barritas grises
#define RED 0xF800       
#define GREEN 0x07E0     // Verde para éxito
#define BLUE_BAR 0x2258
#define ORANGE 0xFD20    // Naranja para procesando

// Semáforo para proteger las variables de fecha/hora
SemaphoreHandle_t dateTimeSemaphore;

// Declaramos una variable global para el color del texto de la hora/fecha
volatile uint16_t currentTextColor = TEXT_COLOR; // Inicialmente blanco

// Variables para evitar parpadeo - solo redibujar si cambió
String lastDisplayTime = "";
String lastDisplayDate = "";
int lastPinDigitsCount = -1;

// Cadenas para almacenar los componentes de la fecha y hora del servidor
String serverDayOfWeek = "Cargando"; // ej. "Friday"
String serverDay = "Da...";                     // ej. "06"
String serverMonth = "Mes...";    // ej. "06" o "Junio"
String serverYear = "";                    // ej. "2025"
String serverHour = "00";                  // ej. "21"
String serverMinute = "00";                // ej. "00"
String serverSecond = "00";                // ej. "35" (no se mostrará en display)

volatile bool HTTP_REQUEST_FLAG = false; // Este flag es usado por la tarea HTTP
String MAC_ADDRESS_STR = "00:00:00:00:00:00"; // Almacenará la MAC real
String IP_ADDRESS = "0.0.0.0";

#define ONBOARD_LED 2
#define BUZZER 10

// Configuración de red - ajusta según tu entorno
String serverAPI_path = "http://192.168.0.47:8000/api/";
String serverAPI_sufijo = "/checkserver";
String serverPIN_sufijo = "/validatepin";  // Nuevo endpoint para validar PIN
const char *WIFI_SSID = "Orange-F05C";
const char *WIFI_PASSWORD = "FWVDQQUN";   //192.168.0.47

#define TRY_TX_POWER

#ifdef TRY_TX_POWER
#define TX_POWER WIFI_POWER_17dBm
#endif

#define TIMEOUT 120000

unsigned long connect_time = 0;
unsigned long etime = 0;
unsigned long dottime = 0;
int count = 0;

// --- Estructura para Tareas de Temporizador ---
typedef struct {
    const uint32_t interval_ms;
    volatile bool flag;
} TimerTask_t;

// --- Definición de las Tareas de Temporizador ---
TimerTask_t timer_tasks[] = {
    {5, false},     // 5ms
    {10, false},    // 10ms
    {50, false},    // 50ms - USADO PARA TECLADO (optimizado de 25ms)
    {100, false},   // 100ms
    {250, false},   // 250ms
    {500, false},   // 500ms
    {1000, false},  // 1 seg (Para refresh del display) - Índice 6
    {2000, false},  // 2 seg
    {5000, false},  // 5 seg
    {20000, false}, // 20 seg (DEBUG para HTTP Request) - Índice 9
    {600000, false} // 10 minutos (600,000 ms para HTTP Request normal) - Índice 10
};

const int num_timer_tasks = sizeof(timer_tasks) / sizeof(timer_tasks[0]);

// --- Variables Globales del Timer ---
esp_timer_handle_t esp_timer_flags_handle = NULL;
volatile SemaphoreHandle_t semaforoTimerFlags;
volatile uint32_t TIMER_ISR_COUNTER = 0;
bool estadoLed = LOW;

// Semáforo para acceso al display TFT
SemaphoreHandle_t tftSemaphore;

// --- Callback de esp_timer (ISR) ---
void IRAM_ATTR espTimerCallback(void *arg) {
    BaseType_t higherPriorityTaskWoken = pdFALSE;

    TIMER_ISR_COUNTER++;

    for (int i = 0; i < num_timer_tasks; i++) {
        if ((TIMER_ISR_COUNTER % timer_tasks[i].interval_ms) == 0) {
            timer_tasks[i].flag = true;
        }
    }
    
    // Activar flag de teclado cada 50ms (optimizado)
    if ((TIMER_ISR_COUNTER % 50) == 0) {
        keypadReadFlag = true;
    }
    
    xSemaphoreGiveFromISR(semaforoTimerFlags, &higherPriorityTaskWoken);
    if (higherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
}

// ===============================================
// FUNCIÓN PARA AGREGAR DÍGITO AL PIN
// ===============================================
void addDigitToPin(char digit) {
    if (xSemaphoreTake(pinSemaphore, portMAX_DELAY) == pdTRUE) {
        // Solo agregar si es un dígito y no hemos alcanzado el máximo
        if (isDigit(digit) && inputDigits.length() < 4) {
            inputDigits += digit;
            
#ifdef DEBUG_KEYPAD
            Serial.printf("Dígito agregado: %c, PIN actual: %s (%d/4)\n", 
                         digit, inputDigits.c_str(), inputDigits.length());
#endif
            
            // Si llegamos a 4 dígitos, preparar para validación
            if (inputDigits.length() == 4) {
                pinReadyForValidation = true;
#ifdef DEBUG_KEYPAD
                Serial.println("PIN completo - Listo para validación");
#endif
            }
        }
        xSemaphoreGive(pinSemaphore);
    }
}

// ===============================================
// FUNCIÓN PARA LIMPIAR PIN
// ===============================================
void clearPin() {
    if (xSemaphoreTake(pinSemaphore, portMAX_DELAY) == pdTRUE) {
        inputDigits = "";
        pinReadyForValidation = false;
        pinValidationInProgress = false;
        pinResult = PENDING;
#ifdef DEBUG_KEYPAD
        Serial.println("PIN limpiado");
#endif
        xSemaphoreGive(pinSemaphore);
    }
}

// ===============================================
// FUNCIÓN PARA PROCESAR TECLAS PRESIONADAS
// ===============================================
void processKeyPress(char key) {
    switch(key) {
        case '1': case '2': case '3':
        case '4': case '5': case '6':
        case '7': case '8': case '9':
        case '0':
            // Solo procesar dígitos si no estamos en validación
            if (!pinValidationInProgress && pinResult == PENDING) {
                addDigitToPin(key);
            }
            break;
            
        case 'A':
#ifdef DEBUG_KEYPAD
            Serial.println("Tecla A - Función especial");
#endif
            // TODO: Función especial A
            break;
            
        case 'B':
#ifdef DEBUG_KEYPAD
            Serial.println("Tecla B - Función especial");
#endif
            // TODO: Función especial B
            break;
            
        case 'C':
#ifdef DEBUG_KEYPAD
            Serial.println("Tecla C - Limpiar PIN");
#endif
            clearPin(); // C = Clear/Limpiar
            break;
            
        case 'D':
#ifdef DEBUG_KEYPAD
            Serial.println("Tecla D - Debug info");
#endif
            // D = Debug - mostrar info actual
            Serial.printf("PIN actual: %s, Longitud: %d\n", inputDigits.c_str(), inputDigits.length());
            break;
            
        case '*':
#ifdef DEBUG_KEYPAD
            Serial.println("Asterisco - Borrar último dígito");
#endif
            // * = Borrar último dígito
            if (xSemaphoreTake(pinSemaphore, portMAX_DELAY) == pdTRUE) {
                if (inputDigits.length() > 0 && !pinValidationInProgress) {
                    inputDigits.remove(inputDigits.length() - 1);
                    pinReadyForValidation = false; // Ya no está listo si borramos
                }
                xSemaphoreGive(pinSemaphore);
            }
            break;
            
        case '#':
#ifdef DEBUG_KEYPAD
            Serial.println("Numeral - Forzar validación");
#endif
            // # = Forzar validación si tenemos al menos 1 dígito
            if (xSemaphoreTake(pinSemaphore, portMAX_DELAY) == pdTRUE) {
                if (inputDigits.length() > 0 && !pinValidationInProgress) {
                    // Completar con ceros si es necesario
                    while (inputDigits.length() < 4) {
                        inputDigits += "0";
                    }
                    pinReadyForValidation = true;
                }
                xSemaphoreGive(pinSemaphore);
            }
            break;
            
        default:
            break;
    }
}

// ===============================================
// TAREA OPTIMIZADA PARA TECLADO
// ===============================================
void KeypadTask(void *pvParameters) {
    Serial.println("KeypadTask iniciada - Lectura optimizada cada 50ms");
    Serial.println("Esta tarea NO perderá teclas durante HTTP requests");
    
    for (;;) {
        // Verificar si es tiempo de leer el teclado (cada 50ms)
        if (keypadReadFlag) {
            keypadReadFlag = false;  // Resetear el flag
            
            char key = keypad.getKey();  // Leer tecla del keypad
            unsigned long currentTime = millis();
            
            // Validación y debounce de tecla
            if (key && key != NO_KEY && key != lastValidKey) {
                // Verificar que haya pasado suficiente tiempo desde la última tecla (debounce)
                if (currentTime - lastKeyTime > KEY_DEBOUNCE_TIME) {
                    // Proteger el acceso a variables compartidas
                    if (xSemaphoreTake(keypadSemaphore, portMAX_DELAY) == pdTRUE) {
                        
#ifdef DEBUG_KEYPAD
                        Serial.printf("Tecla válida detectada: %c\n", key);
#endif
                        
                        // Procesar la tecla
                        processKeyPress(key);
                        
                        // Actualizar variables de control
                        lastValidKey = key;
                        lastKeyTime = currentTime;
                        
                        xSemaphoreGive(keypadSemaphore);
                    }
                }
            } 
            // Reset cuando no hay tecla presionada
            else if (!key || key == NO_KEY) {
                // Resetear la última tecla después del tiempo de debounce
                if (currentTime - lastKeyTime > KEY_DEBOUNCE_TIME) {
                    if (xSemaphoreTake(keypadSemaphore, portMAX_DELAY) == pdTRUE) {
                        lastValidKey = 0;  // Permitir que la misma tecla se presione de nuevo
                        xSemaphoreGive(keypadSemaphore);
                    }
                }
            }
        }
        
        // Ceder control a otras tareas cada 10ms
        vTaskDelay(10 / portTICK_PERIOD_MS);
    }
}

// Función para obtener la MAC Address en formato string
String getMACAddress() {
    uint8_t mac[6];
    esp_read_mac(mac, ESP_MAC_WIFI_STA); // Obtener la MAC de la interfaz Wi-Fi Station
    return String(mac[0], HEX) + ":" +
           String(mac[1], HEX) + ":" +
           String(mac[2], HEX) + ":" +
           String(mac[3], HEX) + ":" +
           String(mac[4], HEX) + ":" +
           String(mac[5], HEX);
}

void getStatus(void) {
    switch (WiFi.status()) {
    case WL_NO_SSID_AVAIL:
        Serial.println("\n[WiFi] SSID not found");
        break;
    case WL_CONNECT_FAILED:
        Serial.print("\n[WiFi] Failed - WiFi not connected! Reason: ");
        return;
        break;
    case WL_CONNECTION_LOST:
        Serial.println("\n[WiFi] Connection was lost");
        break;
    case WL_SCAN_COMPLETED:
        Serial.println("\n[WiFi] Scan is completed");
        break;
    case WL_DISCONNECTED:
        Serial.println("\n[WiFi] WiFi is disconnected");
        break;
    case WL_CONNECTED:
        Serial.print("\n[WiFi] WiFi is connected. IP address: ");
        IP_ADDRESS = WiFi.localIP().toString();
        Serial.println(IP_ADDRESS);
        break;
    default:
        Serial.print("\n[WiFi] WiFi Status: ");
        Serial.println(WiFi.status());
        break;
    }
}

void start_connecting_fer(void) {
    WiFi.mode(WIFI_STA);
    WiFi.setAutoReconnect(true);
#ifdef TRY_TX_POWER
    if (count) {
        delay(25);
        if (WiFi.getTxPower() != TX_POWER) {
            WiFi.setTxPower(TX_POWER);
            delay(25);
        }
    }
    Serial.printf("Wi-Fi TX power set to: %d\n", WiFi.getTxPower());
#endif
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    Serial.println("\nConnecting");
    // Bucle de espera con timeout para la conexión WiFi
    unsigned long wifi_connect_start_time = millis();
    while (WiFi.status() != WL_CONNECTED && (millis() - wifi_connect_start_time < TIMEOUT)) {
        delay(500);
        Serial.print(".");
    }
    if (WiFi.status() == WL_CONNECTED) {
        getStatus();
    } else {
        Serial.println("\nFailed to connect to WiFi within timeout.");
    }
}

// Función para obtener una copia segura de las variables de fecha/hora
void getDateTimeValues(String &dayOfWeek, String &day, String &month, String &year, String &hour, String &minute) {
    if (xSemaphoreTake(dateTimeSemaphore, portMAX_DELAY) == pdTRUE) {
        dayOfWeek = serverDayOfWeek;
        day = serverDay;
        month = serverMonth;
        year = serverYear;
        hour = serverHour;
        minute = serverMinute;
        xSemaphoreGive(dateTimeSemaphore);
    }
}

// Función para actualizar las variables de fecha/hora de forma segura
void setDateTimeValues(const String &dayOfWeek, const String &day, const String &month, const String &year, const String &hour, const String &minute, const String &second) {
    if (xSemaphoreTake(dateTimeSemaphore, portMAX_DELAY) == pdTRUE) {
        serverDayOfWeek = dayOfWeek;
        serverDay = day;
        serverMonth = month;
        serverYear = year;
        serverHour = hour;
        serverMinute = minute;
        serverSecond = second;
        xSemaphoreGive(dateTimeSemaphore);
    }
}

// Función para centrar texto correctamente
int getCenteredX(String text, int font_size) {
    tft.setTextSize(1); // Temporal para medir
    int width = tft.textWidth(text, font_size);
    return (tft.width() - width) / 2;
}

// ===============================================
// FUNCIÓN PARA DIBUJAR INDICADORES DE PIN
// ===============================================
void drawPinIndicators() {
    int circle_radius = 4;  // Radio de los círculos
    int bar_width = 30;     // Ancho de las barras
    int bar_height = 8;     // Alto de las barras
    int spacing = 15;       // Espacio entre elementos
    int y_pos = tft.height() - 50; // Posición Y cerca del fondo

    // Calcular X inicial para centrar 4 elementos
    int total_width = (bar_width * 4) + (spacing * 3);
    int start_x = (tft.width() - total_width) / 2;
    
    // Obtener cantidad actual de dígitos de forma segura
    int digits_count = 0;
    if (xSemaphoreTake(pinSemaphore, 10 / portTICK_PERIOD_MS) == pdTRUE) {
        digits_count = inputDigits.length();
        xSemaphoreGive(pinSemaphore);
    }
    
    // Dibujar los 4 indicadores
    for (int i = 0; i < 4; i++) {
        int x_pos = start_x + (bar_width + spacing) * i + bar_width/2;
        
        if (i < digits_count) {
            // Dibujar círculo blanco para dígito ingresado
            tft.fillCircle(x_pos, y_pos + bar_height/2, circle_radius, TFT_WHITE);
        } else {
            // Dibujar barra gris para posición vacía
            int bar_x = start_x + (bar_width + spacing) * i;
            tft.fillRect(bar_x, y_pos, bar_width, bar_height, GREY_DOTS);
        }
    }
}

// ===============================================
// FUNCIÓN PARA DIBUJAR ESTADO DE VALIDACIÓN
// ===============================================
void drawValidationStatus() {
    if (xSemaphoreTake(tftSemaphore, portMAX_DELAY) == pdTRUE) {
        // Limpiar área de mensaje
        tft.fillRect(0, 140, tft.width(), 40, TFT_BLACK);
        
        String message = "";
        uint16_t color = TFT_WHITE;
        
        if (pinValidationInProgress) {
            message = "Validando...";
            color = ORANGE;
        } else if (pinResult == SUCCESS) {
            message = "PIN Correcto!";
            color = GREEN;
        } else if (pinResult == FAILED) {
            message = "PIN Incorrecto";
            color = RED;
        }
        
        if (message.length() > 0) {
            tft.setTextColor(color, TFT_BLACK);
            int msgX = getCenteredX(message, 4);
            tft.drawString(message, msgX, 150, 4);
        }
        
        xSemaphoreGive(tftSemaphore);
    }
}

// ===============================================
// FUNCIÓN OPTIMIZADA PARA DIBUJAR FECHA Y HORA
// ===============================================
void drawDateTime() {
    if (xSemaphoreTake(tftSemaphore, portMAX_DELAY) == pdTRUE) {
        // Obtener copias seguras de las variables
        String dayOfWeek, day, month, year, hour, minute;
        getDateTimeValues(dayOfWeek, day, month, year, hour, minute);

        // Crear strings para comparación
        String currentTime = hour + ":" + minute;
        String currentDate = dayOfWeek + " " + day + "," + month + " " + year;
        
        // Obtener cantidad de dígitos PIN para comparación
        int currentPinDigits = 0;
        if (xSemaphoreTake(pinSemaphore, 10 / portTICK_PERIOD_MS) == pdTRUE) {
            currentPinDigits = inputDigits.length();
            xSemaphoreGive(pinSemaphore);
        }

        // Solo redibujar si algo cambió (evitar parpadeo)
        bool needsRedraw = (currentTime != lastDisplayTime) || 
                          (currentDate != lastDisplayDate) ||
                          (currentPinDigits != lastPinDigitsCount);

        if (needsRedraw) {
            // Limpiar solo las áreas necesarias en lugar de toda la pantalla
            tft.fillRect(0, 0, tft.width(), 120, TFT_BLACK); // Área de fecha/hora
            
            // Mostrar dia (ej. Friday 06,)
            tft.setTextColor(currentTextColor, TFT_BLACK);
            String formattedDay = dayOfWeek + " " + day + "," ;
            int dayX = getCenteredX(formattedDay, 4);
            tft.drawString(formattedDay, dayX, 7, 4);

            // Mostrar mes (ej. mayo 2025)
            String formattedMes = month + " " + year;
            int mesX = getCenteredX(formattedMes, 4);
            tft.drawString(formattedMes, mesX, 32, 4);

            // Mostrar Hora (ej. 21:15)
            int timeX = getCenteredX(currentTime, 8);
            tft.drawString(currentTime, timeX, 60, 8);

            // Actualizar variables de control
            lastDisplayTime = currentTime;
            lastDisplayDate = currentDate;
            lastPinDigitsCount = currentPinDigits;
        }
        
        // Siempre redibujar los indicadores de PIN (pueden cambiar independientemente)
        // Limpiar área de indicadores
        tft.fillRect(0, tft.height() - 60, tft.width(), 60, TFT_BLACK);
        drawPinIndicators();
        
        // Dibujar estado de validación si es necesario
        drawValidationStatus();

        xSemaphoreGive(tftSemaphore);
    }
}

// ===============================================
// TAREA OPTIMIZADA PARA DISPLAY
// ===============================================
void DisplayTask(void *pvParameters) {
    Serial.println("DisplayTask iniciada - Refresh optimizado");
    for (;;) {
        if (timer_tasks[6].flag) { // Índice 6 es para 1000ms (reducido de 500ms)
            timer_tasks[6].flag = false; // Resetear el flag
            drawDateTime(); // Redibuja solo si es necesario
        }
        vTaskDelay(20 / portTICK_PERIOD_MS); // Ceder el control
    }
}

// ===============================================
// FUNCIÓN PARA VALIDAR PIN EN SERVIDOR
// ===============================================
bool validatePinOnServer(String pin) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi no conectado para validación de PIN");
        return false;
    }

    HTTPClient http;
    String serverPIN_request = serverAPI_path + "AA:BB:CC:DD:EE:FF" + serverPIN_sufijo;
    
    Serial.println("=== VALIDACIÓN DE PIN EN SERVIDOR ===");
    Serial.print("Conectando a: ");
    Serial.println(serverPIN_request);
    Serial.print("PIN a validar: ");
    Serial.println(pin);

    http.begin(serverPIN_request.c_str());
    http.addHeader("Content-Type", "application/json");
    http.setConnectTimeout(10000); // 10 segundos

    // Crear JSON con el PIN
    DynamicJsonDocument doc(128);
    doc["pin"] = pin;
    String jsonString;
    serializeJson(doc, jsonString);

    int httpResponseCode = http.POST(jsonString);

    if (httpResponseCode > 0) {
        Serial.print("HTTP Response code: ");
        Serial.println(httpResponseCode);
        String payload = http.getString();
        Serial.println(payload);

        DynamicJsonDocument responseDoc(256);
        DeserializationError error = deserializeJson(responseDoc, payload);

        if (!error) {
            bool isValid = responseDoc["valid"];
            http.end();
            return isValid;
        } else {
            Serial.print("Error parseando respuesta JSON: ");
            Serial.println(error.f_str());
        }
    } else {
        Serial.print("HTTP Error code: ");
        Serial.println(httpResponseCode);
    }
    
    http.end();
    return false; // En caso de error, considerar PIN inválido
}

// ===============================================
// TAREA HTTP MEJORADA CON VALIDACIÓN DE PIN
// ===============================================

void HTTPRequestTask(void *pvParameters) {
    Serial.println("HTTPRequestTask iniciada - Con validación de PIN");
    for (;;) {
        bool processPeriodicRequest = false;
        bool processPinValidation = false;
        
        // Verificar si hay PIN listo para validación (prioridad alta)
        if (xSemaphoreTake(pinSemaphore, 10 / portTICK_PERIOD_MS) == pdTRUE) {
            if (pinReadyForValidation && !pinValidationInProgress) {
                processPinValidation = true;
                pinValidationInProgress = true;
                pinReadyForValidation = false;
            }
            xSemaphoreGive(pinSemaphore);
        }
        
        // Verificar timer para request periódico
#ifdef DEBUG_20_SEC_REQUEST
        if (timer_tasks[9].flag) { // 20 segundos para debug
            processPeriodicRequest = true;
            timer_tasks[9].flag = false;
        }
#else
        if (timer_tasks[10].flag) { // 10 minutos para operación normal
            processPeriodicRequest = true;
            timer_tasks[10].flag = false;
        }
#endif

        // Procesar validación de PIN (prioridad)
        if (processPinValidation) {
            httpRequestInProgress = true;
            Serial.println("=== VALIDANDO PIN ===");
            
            // Obtener PIN de forma segura
            String pinToValidate = "";
            if (xSemaphoreTake(pinSemaphore, portMAX_DELAY) == pdTRUE) {
                pinToValidate = inputDigits;
                xSemaphoreGive(pinSemaphore);
            }
            
            // Mostrar estado de validación
            drawValidationStatus();
            
            // Validar en servidor
            bool isValid = validatePinOnServer(pinToValidate);
            
            // Actualizar resultado
            if (xSemaphoreTake(pinSemaphore, portMAX_DELAY) == pdTRUE) {
                pinResult = isValid ? SUCCESS : FAILED;
                pinValidationInProgress = false;
                pinResultDisplayTime = millis(); // Marcar tiempo para mostrar resultado
                xSemaphoreGive(pinSemaphore);
            }
            
            // Actualizar display con resultado
            drawValidationStatus();
            
            httpRequestInProgress = false;
            Serial.println(isValid ? "PIN VÁLIDO" : "PIN INVÁLIDO");
        }
        
        // Procesar request periódico normal
        if (processPeriodicRequest && !httpRequestInProgress) {
            httpRequestInProgress = true;
            Serial.println("=== REQUEST PERIÓDICO ===");
            
            // Realizar request normal de fecha/hora
            performPeriodicHTTPRequest();
            
            httpRequestInProgress = false;
        }
        
        // Verificar si hay que limpiar PIN después de mostrar resultado
        if (pinResult != PENDING && (millis() - pinResultDisplayTime) > PIN_RESULT_SHOW_DURATION) {
            if (xSemaphoreTake(pinSemaphore, 10 / portTICK_PERIOD_MS) == pdTRUE) {
                // Limpiar PIN y resultado
                inputDigits = "";
                pinResult = PENDING;
                pinValidationInProgress = false;
                pinReadyForValidation = false;
                Serial.println("PIN limpiado automáticamente después de mostrar resultado");
                xSemaphoreGive(pinSemaphore);
            }
        }
        
        vTaskDelay(100 / portTICK_PERIOD_MS); // Ceder control
    }
}

// 2. FUNCIÓN PARA REQUEST PERIÓDICO (similar al inicial pero sin cambiar currentTextColor)
bool performPeriodicHTTPRequest() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi no conectado para request periódico");
        return false;
    }

    HTTPClient http;
    String serverAPI_request = serverAPI_path + MAC_ADDRESS_STR + serverAPI_sufijo;
    
    Serial.println("=== REQUEST PERIÓDICO DE FECHA/HORA ===");
    Serial.print("Conectando a: ");
    Serial.println(serverAPI_request);

    http.begin(serverAPI_request.c_str());
    http.setConnectTimeout(10000);

    int httpResponseCode = http.GET();

    if (httpResponseCode > 0) {
        Serial.print("HTTP Response code: ");
        Serial.println(httpResponseCode);
        String payload = http.getString();
        Serial.println(payload);

        DynamicJsonDocument doc(256);
        DeserializationError error = deserializeJson(doc, payload);

        if (error) {
            Serial.print(F("deserializeJson() failed: "));
            Serial.println(error.f_str());
            http.end();
            return false;
        } else {
            const char* serverOK_str = doc["serverOK"];
            if (serverOK_str) {
                String dateTimeStr = String(serverOK_str);
                Serial.print("Received DateTime String: ");
                Serial.println(dateTimeStr);

                int first_underscore = dateTimeStr.indexOf('_');
                int second_underscore = dateTimeStr.indexOf('_', first_underscore + 1);

                if (first_underscore != -1 && second_underscore != -1) {
                    String newDayOfWeek = dateTimeStr.substring(0, first_underscore);
                    String datePart = dateTimeStr.substring(first_underscore + 1, second_underscore);
                    String timePart = dateTimeStr.substring(second_underscore + 1);

                    String newDay, newMonth, newYear;
                    int dash1 = datePart.indexOf('-');
                    int dash2 = datePart.indexOf('-', dash1 + 1);
                    if (dash1 != -1 && dash2 != -1) {
                        newDay = datePart.substring(0, dash1);
                        newMonth = datePart.substring(dash1 + 1, dash2);
                        newYear = datePart.substring(dash2 + 1);
                    }

                    String newHour, newMinute, newSecond;
                    int colon1 = timePart.indexOf(':');
                    int colon2 = timePart.indexOf(':', colon1 + 1);
                    if (colon1 != -1 && colon2 != -1) {
                        newHour = timePart.substring(0, colon1);
                        newMinute = timePart.substring(colon1 + 1, colon2);
                        newSecond = timePart.substring(colon2 + 1);
                    }

                    // Actualizar las variables de forma segura
                    setDateTimeValues(newDayOfWeek, newDay, newMonth, newYear, newHour, newMinute, newSecond);

                    Serial.println("Request periódico exitoso");
                    http.end();
                    return true;
                } else {
                    Serial.println("Error parsing periodic date/time string format.");
                    http.end();
                    return false;
                }
            } else {
                Serial.println("JSON field 'serverOK' not found in periodic request.");
                http.end();
                return false;
            }
        }
    } else {
        Serial.print("HTTP Error code: ");
        Serial.println(httpResponseCode);
        http.end();
        return false;
    }
}

// 3. FUNCIÓN performInitialHTTPRequest() CORREGIDA (usar MAC real)
bool performInitialHTTPRequest() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("WiFi no conectado para request inicial");
        currentTextColor = RED;
        return false;
    }

    HTTPClient http;
    // CORREGIDO: Usar MAC_ADDRESS_STR en lugar de MAC hardcodeado
    String serverAPI_request = serverAPI_path + MAC_ADDRESS_STR + serverAPI_sufijo;
    
    Serial.println("=== REQUEST INICIAL DE FECHA/HORA ===");
    Serial.print("Conectando a: ");
    Serial.println(serverAPI_request);

    http.begin(serverAPI_request.c_str());
    http.setConnectTimeout(10000);

    int httpResponseCode = http.GET();

    if (httpResponseCode > 0) {
        Serial.print("HTTP Response code: ");
        Serial.println(httpResponseCode);
        String payload = http.getString();
        Serial.println(payload);

        DynamicJsonDocument doc(256);
        DeserializationError error = deserializeJson(doc, payload);

        if (error) {
            Serial.print(F("deserializeJson() failed: "));
            Serial.println(error.f_str());
            http.end();
            currentTextColor = RED;
            return false;
        } else {
            const char* serverOK_str = doc["serverOK"];
            if (serverOK_str) {
                String dateTimeStr = String(serverOK_str);
                Serial.print("Received DateTime String: ");
                Serial.println(dateTimeStr);

                int first_underscore = dateTimeStr.indexOf('_');
                int second_underscore = dateTimeStr.indexOf('_', first_underscore + 1);

                if (first_underscore != -1 && second_underscore != -1) {
                    String newDayOfWeek = dateTimeStr.substring(0, first_underscore);
                    String datePart = dateTimeStr.substring(first_underscore + 1, second_underscore);
                    String timePart = dateTimeStr.substring(second_underscore + 1);

                    String newDay, newMonth, newYear;
                    int dash1 = datePart.indexOf('-');
                    int dash2 = datePart.indexOf('-', dash1 + 1);
                    if (dash1 != -1 && dash2 != -1) {
                        newDay = datePart.substring(0, dash1);
                        newMonth = datePart.substring(dash1 + 1, dash2);
                        newYear = datePart.substring(dash2 + 1);
                    }

                    String newHour, newMinute, newSecond;
                    int colon1 = timePart.indexOf(':');
                    int colon2 = timePart.indexOf(':', colon1 + 1);
                    if (colon1 != -1 && colon2 != -1) {
                        newHour = timePart.substring(0, colon1);
                        newMinute = timePart.substring(colon1 + 1, colon2);
                        newSecond = timePart.substring(colon2 + 1);
                    }

                    setDateTimeValues(newDayOfWeek, newDay, newMonth, newYear, newHour, newMinute, newSecond);
                    currentTextColor = TEXT_COLOR;

                    Serial.println("=== DATOS INICIALES OBTENIDOS ===");
                    Serial.print("Day of Week: "); Serial.println(newDayOfWeek);
                    Serial.print("Day: "); Serial.println(newDay);
                    Serial.print("Month: "); Serial.println(newMonth);
                    Serial.print("Year: "); Serial.println(newYear);
                    Serial.print("Hour: "); Serial.println(newHour);
                    Serial.print("Minute: "); Serial.println(newMinute);
                    Serial.print("Second: "); Serial.println(newSecond);
                    Serial.println("================================");

                    http.end();
                    return true;
                } else {
                    Serial.println("Error parsing initial date/time string format.");
                    http.end();
                    currentTextColor = RED;
                    return false;
                }
            } else {
                Serial.println("JSON field 'serverOK' not found in initial request.");
                http.end();
                currentTextColor = RED;
                return false;
            }
        }
    } else {
        Serial.print("HTTP Error code: ");
        Serial.println(httpResponseCode);
        http.end();
        currentTextColor = RED;
        return false;
    }
}

// 4. SETUP() CORREGIDO - Agregar semáforos faltantes
void setup() {
    Serial.begin(115200);
    delay(100);

    // Configuración explícita de pines
    for(int i = 0; i < ROWS; i++) {
        pinMode(rowPins[i], INPUT_PULLUP);
    }
    for(int i = 0; i < COLS; i++) {
        pinMode(colPins[i], OUTPUT);
        digitalWrite(colPins[i], HIGH);
    }
  
    pinMode(ONBOARD_LED, OUTPUT);
    pinMode(BUZZER, OUTPUT);

    MAC_ADDRESS_STR = getMACAddress();
    MAC_ADDRESS_STR.toUpperCase();
    Serial.print("MAC Address: ");
    Serial.println(MAC_ADDRESS_STR);

    start_connecting_fer();

    Serial.println("Iniciando configuración TFT...");
    tft.begin();
    tft.init();
    tft.setRotation(3);
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawString("IP: ", 5, 5, 4);
    tft.drawString(IP_ADDRESS, 40, 5, 4);
    delay(3000);

    // Crear TODOS los semáforos ANTES de usarlos
    semaforoTimerFlags = xSemaphoreCreateBinary();
    if (semaforoTimerFlags == NULL) {
        Serial.println("Error semáforo flags!");
        ESP.restart();
    }
    xSemaphoreGive(semaforoTimerFlags);

    tftSemaphore = xSemaphoreCreateMutex();
    if (tftSemaphore == NULL) {
        Serial.println("Error creando mutex TFT!");
        ESP.restart();
    }

    dateTimeSemaphore = xSemaphoreCreateMutex();
    if (dateTimeSemaphore == NULL) {
        Serial.println("Error creando mutex DateTime!");
        ESP.restart();
    }

    // AGREGAR: Crear semáforos para teclado y PIN
    keypadSemaphore = xSemaphoreCreateMutex();
    if (keypadSemaphore == NULL) {
        Serial.println("Error creando mutex Keypad!");
        ESP.restart();
    }

    pinSemaphore = xSemaphoreCreateMutex();
    if (pinSemaphore == NULL) {
        Serial.println("Error creando mutex PIN!");
        ESP.restart();
    }

    // Mostrar mensaje de "Obteniendo hora..."
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    int loadingX = getCenteredX("Obteniendo hora...", 4);
    tft.drawString("Obteniendo hora...", loadingX, 100, 4);

    // Realizar request inicial de fecha/hora
    bool initialRequestSuccess = performInitialHTTPRequest();
    
    if (!initialRequestSuccess) {
        Serial.println("Fallo en request inicial, continuando con valores por defecto");
        tft.fillScreen(TFT_BLACK);
        tft.setTextColor(RED, TFT_BLACK);
        int errorX = getCenteredX("Error obteniendo hora", 4);
        tft.drawString("Error obteniendo hora", errorX, 100, 4);
        delay(2000);
    } else {
        Serial.println("Request inicial exitoso, mostrando datos obtenidos");
    }

    // Configurar timer después de obtener datos iniciales
    esp_timer_create_args_t timer_args = {
        .callback = &espTimerCallback,
        .arg = NULL,
        .name = "flags_timer"
    };

    ESP_ERROR_CHECK(esp_timer_create(&timer_args, &esp_timer_flags_handle));
    ESP_ERROR_CHECK(esp_timer_start_periodic(esp_timer_flags_handle, 1000)); // 1ms

    Serial.println("Timer Flags (1ms) configurado con esp_timer.");
    Serial.printf("Número de tareas de temporizador configuradas: %d\n", num_timer_tasks);

    // Crear TODAS las tareas incluyendo KeypadTask
    xTaskCreatePinnedToCore(
        KeypadTask,        // AGREGAR: Tarea de teclado
        "KeypadTask",
        4096,
        NULL,
        3,                 // Prioridad alta para teclado
        NULL,
        0
    );

    xTaskCreatePinnedToCore(
        DisplayTask,
        "DisplayTask",
        4096,
        NULL,
        2,
        NULL,
        1
    );

    xTaskCreatePinnedToCore(
        HTTPRequestTask,
        "HTTPRequestTask",
        8192,
        NULL,
        1,
        NULL,
        0
    );

    Serial.println("Setup completado, mostrando datos iniciales...");
    drawDateTime(); // Dibuja con los datos obtenidos
}

// 5. LOOP() CORREGIDO - Eliminar lectura de teclado (ya la maneja KeypadTask)
void loop() {
    // ELIMINAR: Ya no necesitamos leer teclado aquí
    // KEY = keypad.getKey();
    // if (KEY) {
    //     Serial.printf("Tecla presionada: %c\n", KEY);    
    // }
    
    if (xSemaphoreTake(semaforoTimerFlags, portMAX_DELAY) == pdTRUE) {
        for (int i = 0; i < num_timer_tasks; i++) {
            // Procesar todos los flags excepto los que manejan las tareas dedicadas
            if (i != 6 && i != 9 && i != 10) { // Excluir display task y HTTP request tasks
                if (timer_tasks[i].flag) {
                    uint32_t interval = timer_tasks[i].interval_ms;

                    if (interval == 100) {
                        digitalWrite(BUZZER, LOW);
                    } else if (interval == 500) {
                        estadoLed = !estadoLed;
                        digitalWrite(ONBOARD_LED, estadoLed);
                        // Serial.println("LED toggle - 500ms timer"); // Comentar para reducir logs
                    } else if (interval == 5000) {
                        Serial.println("timer 5Seg - (managed by main loop)");
                    }
                    timer_tasks[i].flag = false;
                }
            }
        }
    }
}



/*
2. Sistema de Almacenamiento de Dígitos
Necesitas crear:

Una variable global String inputDigits = "" (máximo 4 caracteres)
Una función addDigit(char digit) que:

Valide que sea un dígito (0-9)
Solo agregue si inputDigits.length() < 4
Actualice el display inmediatamente
Si llega a 4 dígitos, active un flag para HTTP request



3. Visualización de Dígitos Enmascarados
Modificar la función drawDateTime():

Reemplazar las 4 barras azules por círculos según inputDigits.length()
Círculos llenos blancos para dígitos ingresados
Barras grises para posiciones vacías
Usar tft.fillCircle(x, y, radio, TFT_WHITE) para los círculos

4. Sistema de Request por PIN
Crear nueva lógica:

Flag bool pinReadyForValidation = false
Cuando inputDigits.length() == 4, activar este flag
En HTTPRequestTask, verificar este flag antes que los timers
Crear endpoint específico para validación de PIN
Limpiar inputDigits después del request (exitoso o fallido)

5. Solución al Parpadeo del Display
El parpadeo se debe a:

tft.fillScreen(TFT_BLACK) borra toda la pantalla antes de redibujar
Frecuencia de 500ms es muy alta para un reloj

Soluciones:

Refresh selectivo: Solo redibujar las partes que cambiaron
Double buffering conceptual: Comparar valores antiguos vs nuevos
Reducir frecuencia: Cambiar a 1000ms para el reloj, pero mantener refresh inmediato para los círculos de PIN
Optimizar SPI: Aumentar velocidad del SPI en la configuración de TFT_eSPI

6. Arquitectura Mejorada de Tareas
Modificaciones sugeridas:

KeypadTask: Solo lectura y procesamiento de teclas
DisplayTask: Dividir en dos funciones: updateClock() y updatePinDisplay()
HTTPRequestTask: Manejar tanto requests periódicos como validación de PIN
Añadir PinValidationTask: Específica para manejar el flujo de validación

7. Variables y Estados Adicionales
agregar variables necesarias:

8. Flujo de Validación de PIN
Secuencia propuesta:

Usuario ingresa dígitos → se muestran círculos
Al 4to dígito → request inmediato al servidor
Durante validación → mostrar indicador de "procesando"
Resultado → mostrar éxito (verde) o error (rojo) por 2-3 segundos
Limpiar PIN y volver al display normal

9. Optimizaciones de Rendimiento
Para el SPI y display:

Verificar configuración de velocidad en User_Setup.h de TFT_eSPI
Usar tft.setSwapBytes(true) si es necesario
Implementar dirty flags para solo redibujar elementos modificados

Para el sistema general:

Reducir stack size de tareas no críticas
Usar vTaskDelayUntil() en lugar de vTaskDelay() para timing preciso
Considerar usar interrupciones GPIO para el teclado en lugar de polling

//==============================================================================================
Principales Correcciones y Completado:
1. HTTPRequestTask Completada

Terminé la función que se cortó
Agregué manejo de limpieza automática del PIN después de mostrar resultado por 3 segundos
Separé request periódico del de validación de PIN

2. Setup() Corregido

CRÍTICO: Agregué la creación de keypadSemaphore y pinSemaphore (estaban faltando)
Agregué la creación de KeypadTask que no estaba en tu setup original
Corregí el uso de MAC real en lugar del hardcodeado "AA:BB:CC:DD:EE:FF"

3. Loop() Optimizado

Eliminé la lectura redundante del teclado - ahora solo la maneja KeypadTask
Corregí los índices de exclusión de timers
Comenté el log del LED para reducir ruido en consola

4. Nuevas Funciones Agregadas

performPeriodicHTTPRequest() - Para requests normales sin afectar currentTextColor
Lógica de limpieza automática del PIN

5. Funcionalidad del Sistema PIN

Dígitos 0-9: Se agregan al PIN y muestran círculos
Tecla C: Limpia todo el PIN
**Tecla ***: Borra último dígito
Tecla #: Fuerza validación (rellena con ceros si es necesario)
4 dígitos: Validación automática
Resultado: Se muestra por 3 segundos y luego se limpia automáticamente

6. Optimizaciones Implementadas

Teclado independiente que no se bloquea durante HTTP requests
Display solo se redibuja cuando hay cambios (elimina parpadeo)
Semáforos para proteger todas las variables compartidas
Gestión inteligente de estados de PIN
*/